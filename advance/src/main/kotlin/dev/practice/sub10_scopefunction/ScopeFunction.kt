package dev.practice.sub10_scopefunction

/**
 * [1]
 *
 * 코틀린의 스코프 함수에 대해 알아본다.
 *
 * 개인적 생각..
 * 코틀린에는 Java 에 없던.. 확장 함수에 대한 개념이 생겨서..
 * 확장 함수를 Java 의 함수형 인터페이스 비슷하게 만들어 놓은 느낌인듯 하다..
 *
 * 1. 코틀린의 표준 라이브러리에는 객체의 컨텍스트 내에서
 * 코드 블럭을 실행하기 위해서만 존재하는 몇가지 함수가 포함되어있다.
 * 이를 스코프 함수라 부른다.
 *
 * 2. 스코프 함수를 제대로 사용하면 불필요한 변수 선언이 없어지며
 * 코드를 더 간결하고 읽기 쉽게 만든다.
 *
 * 3. 스코프 함수의 코드 블럭 내부에서는
 * 변수명을 사용하지 않고도 객체에 접근할 수 있는데
 * 그 이유는 수신자 객체에 접근할 수 있기 때문이다.
 *
 * 4. 수신자 객체는 람다식 내부에서 사용할 수 있는 객체의 참조이다.
 *
 * 5. 스코프 함수를 사용하면 수신자 객체에 대한 참조로 this 또는 it 을 사용한다.
 *
 * 6. 스코프 함수 블럭 {} 도 하나의 파라미터 인듯.. (고차 함수 개념인듯..)
 * 구현체 코드를 보면 대략적으로 유추해볼 수 있다. (run 을 봐라.. 파라미터로 코드 블럭을 받는 것 같다..)
 *
 * 7. 스코프 함수 5종은.. 굉장히 기능이 유사하다..
 * 그래서 실무에서는 딱히 구분해서 사용하지 않는 경우도 많다.
 *
 * 8. 사실 ... it 를 사용하지 않고 직접 수신자 객체 참조 변수를 선언하고 사용할 수 도 있다.
 *
 *
 *
 *
 * 스코프 함수 종류..
 *
 * let
 * - it 으로 수신자 객체 참조, 함수의 마지막 코드 줄의 값이 반환 값, 확장 함수로 구현됨
 *
 * run
 * - this 로 수신자 객체 참조, 함수의 마지막 코드 줄의 값이 반환 값, 확장 함수로 구현됨
 *
 * with
 * - this 로 수신자 객체 참조, 함수의 마지막 코드 줄의 값이 반환 값, 확장 함수로 구현되지 않음
 *
 * apply
 * - this 로 수신자 객체 참조, 컨텍스트 객체가 반환 값, 확장 함수로 구현됨
 *
 * also
 * - it 으로 수신자 객체 참조, 컨텍스트 객체가 반환 값, 확장 함수로 구현됨
 *
 * TODO 위 5종 외에 3가지가 더 있는 것 같다. takeIf, takeUnless, repeat
 */

// [7]
fun main() {

    val hello = "hello"
    hello.let { s: String -> println(s) } // 수신자 객체 참조 변수를 it 대신 직접 선언해서 사용할 수 도 있다.
    // 참고로 this 는 직접 선언한 변수 명으로 대체가 불가능한 것 같다..

    // -------------------------------------------------------

    //스코프 함수의 파라미터 타입에 대해.. 공부해보자..
    //-> sub13 에 나오는 주제로 코틀린의 함수는 일급 객체라 변수에 할당이 가능하고
    // 다른 함수에 인자가 될 수 있다. (그 다른 함수는 고차함수가 되겠네)
    val str = "str"

    val block: String.() -> Unit = { }
    str.apply(block)

    val block1: String.() -> Unit = {}
    str.run(block1)

    val block2: (String) -> Unit = { }
    str.let(block2)
}